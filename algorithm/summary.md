## 动态规划

1. 背包问题
   - 01背包
   - 完全背包
   - 多重背包

## 双指针

1. 一头一尾
2. 一前一后
3. 一快一慢



#### 注意点：

1. 指针的具体意义，从而知道他们的移动方式（一般方式都是简单的遍历移动，但是本质上还是根据实际算法需求来的）
   - 谁移动，谁固定
   - 什么时候移动/为什么移动
   - 移动的步长



## 滑动窗口

1. 进一个，出一个，然后看现在的窗口结果
1. 直接比较一进一出的差异



## 链表

1. 变量多用是正常的，可以帮助理清思路，后续再优化就行。不过有时候看了题解，确实会用到很多变量
2. dummy：根据我做题的有限经验，感觉需要使用到“前一个节点”的题目基本上加了dummy都会让代码更清晰些



#### 题目推荐：

1. LeetCode143（个人认为很好的题目）



## 数组：

1. 前缀和：前缀和可以将中间结果存储起来，从而减少时间复杂度；并且在一些情形下可以方便计算



## API：

1. map()：根据提供的函数对指定序列做映射

   ```python
   '''
   map(function, iterable, ...)
   - function：函数
   - iterable：一个或多个序列
   '''
   
   >>> def square(x) :         # 计算平方数
   ...     return x ** 2
   ...
   >>> map(square, [1,2,3,4,5])    # 计算列表各个元素的平方
   <map object at 0x100d3d550>     # 返回迭代器
   >>> list(map(square, [1,2,3,4,5]))   # 使用 list() 转换为列表
   [1, 4, 9, 16, 25]
   >>> list(map(lambda x: x ** 2, [1, 2, 3, 4, 5]))   # 使用 lambda 匿名函数
   [1, 4, 9, 16, 25]
   
   >>> def add(x, y) :         # 计算两数之和
   ...     return x + y
   ...
   >>> list(map(square, [1,2,3], [4,5,6]))   # 使用 list() 转换为列表
   [5, 7, 9]
   ```



## 哈希表：

1. 选择key的时候是很灵活的
   - 比如以列表元素值作为key，以列表索引作为value
   - key的选择也不一定就是已有的值，可以对已有值做一点通用处理，从而优化代码



## 字符串：

1. 排序：
   - for遍历sorted(s)，然后依次拼接字符串（注意str没有sort()方法）
   - 转化为列表：ls = list(s)，然后对列表排序sort(ls)，用join拼接列表元素
2. 字符串转化成列表，然后用列表的方式去操作字符串
3. 把字符串本身double



## Trick：

1. dif的使用：在双指针和滑动窗口（滑动窗口其实也算是双指针吧）中，可以用dif来统计差别
2. 字典所有value的判断，学会使用all()：all(value <= 0 for value in count.values())的使用
2. 有时候把字符串转化为列表会比较好操作
2. directions = [[0, 1], [1, 0], [0, -1], [-1, 0]]，we can learn this method, which is a common practice and can make our codes concise.



## 经典算法：

### KMP

1. 前缀表：最长相等前后缀

   - 前缀：包含首字符，不包含尾字符的所有子串
   - 后缀：包含尾字符，不包含首字符的所有子串

   示例：aabaaf的前缀表就是010120



## 队列

1. 单调队列
